<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokamon Crush - Match-3 Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: white;
        }

        .game-container {
            width: 100%;
            max-width: 500px;
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center;
            overflow: hidden;
            position: relative;
        }

        .game-header {
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .game-title {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .creator {
            font-size: 1rem;
            opacity: 0.8;
            margin-bottom: 20px;
        }

        .score-container {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 10px 20px;
            border-radius: 50px;
            display: inline-block;
            margin-bottom: 20px;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        #game-board {
            width: 100%;
            aspect-ratio: 1 / 1;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            padding: 5px;
            margin-bottom: 20px;
        }

        .tile {
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .tile.selected {
            transform: scale(0.9);
            box-shadow: 0 0 0 3px #4ade80, 0 0 15px #4ade80;
            z-index: 10;
        }

        .tile.matched {
            animation: pop 0.5s ease forwards;
        }

        .tile img {
            width: 80%;
            height: 80%;
            object-fit: contain;
            transition: all 0.3s ease;
        }

        .tile.swapping {
            z-index: 5;
            transition: transform 0.3s ease;
        }

        .tile.falling {
            z-index: 1;
            transition: transform 0.5s ease;
        }

        @keyframes pop {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.7;
            }
            100% {
                transform: scale(0);
                opacity: 0;
            }
        }
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 100;
            padding: 20px;
            text-align: center;
            border-radius: 20px;
        }

        .screen h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #4ade80;
        }

        .screen p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            max-width: 80%;
            line-height: 1.5;
        }

        .btn {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            font-weight: bold;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .restart-btn {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            padding: 12px 25px;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .restart-btn i {
            font-size: 1.2rem;
        }

        #game-over-screen {
            display: none;
        }

        #start-screen {
            display: flex;
        }

        .instructions {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 1rem;
        }

        #restart-btn-game {
            display: none;
        }

        @media (max-width: 500px) {
            .game-title {
                font-size: 2rem;
            }
            
            .screen h2 {
                font-size: 2rem;
            }
            
            .screen p {
                font-size: 1rem;
            }
            
            .btn {
                padding: 12px 30px;
                font-size: 1rem;
            }
            
            .game-header {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <div>
                <h1 class="game-title">Pokamon Crush</h1>
                <p class="creator">Created by Samridhya</p>
            </div>
            <div class="score-container">
                Score: <span id="score">0</span>
            </div>
        </div>
        
        <div class="controls">
            <button id="restart-btn-game" class="btn restart-btn">
                <i>↻</i> Restart Game
            </button>
        </div>
        
        <div id="game-board"></div>
        
        <div id="start-screen" class="screen">
            <h2>Match-Heads Puzzle</h2>
            <p>Swap adjacent heads to create rows or columns of three or more identical items!</p>
            <div class="instructions">
                <p>• Tap/click a head to select it</p>
                <p>• Tap/click an adjacent head to swap</p>
                <p>• Match 3 or more to score points</p>
                <p>• Each match plays the head's unique sound</p>
            </div>
            <button id="start-btn" class="btn">Start Game</button>
        </div>
        
        <div id="game-over-screen" class="screen">
            <h2>Game Over</h2>
            <p>Your final score: <span id="final-score">0</span></p>
            <button id="restart-btn" class="btn">Play Again</button>
        </div>
    </div>
<script>
    // Game Constants and Variables
    const BOARD_SIZE = 8;
    const MIN_MATCH = 3;
    
    let gameBoard = [];
    let selectedTile = null;
    let score = 0;
    let isSwapping = false;
    let isProcessing = false;
    let gameActive = false;
    
    // Strict Asset Mapping - Single Source of Truth
    const ASSET_MAP = [
        { name: 'head1', imageFile: 'hotibg.png', soundFile: 'hotibg1.mp3' },
        { name: 'head2', imageFile: 'rtifyh.png', soundFile: 'rtifyh1.mp3' },
        { name: 'head3', imageFile: 'jruvduh.png', soundFile: 'jruvduh1.mp3' },
        { name: 'head4', imageFile: 'sruvr.png', soundFile: 'sruvr1.mp3' },
        { name: 'head5', imageFile: 'ufijfy.png', soundFile: 'ufijfy1.mp3' },
        { name: 'head6', imageFile: 'athfgu.png', soundFile: 'athfgu1.mp3' },
        { name: 'head7', imageFile: 'ghrumj.png', soundFile: 'ghrumj1.mp3' },
        { name: 'head8', imageFile: 'hfuhfy.png', soundFile: 'hfuhfy1.mp3' },
        { name: 'head9', imageFile: 'dgfyb.png', soundFile: 'dgfyb1.mp3' }
    ];
    
    // Audio elements for sounds
    const audioElements = {};
    
    // DOM Elements
    const gameBoardElement = document.getElementById('game-board');
    const scoreElement = document.getElementById('score');
    const finalScoreElement = document.getElementById('final-score');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');
    const restartBtnGame = document.getElementById('restart-btn-game');
    
    // Initialize the game
    function initGame() {
        // Preload audio elements using the ASSET_MAP
        for (let i = 0; i < ASSET_MAP.length; i++) {
            audioElements[i] = new Audio(ASSET_MAP[i].soundFile);
            // Ensure audio can play on mobile devices
            audioElements[i].preload = 'auto';
        }
        
        // Set up event listeners
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', restartGame);
        restartBtnGame.addEventListener('click', restartGame);
        
        // Initial render
        renderBoard();
    }
    
    // Create the game board with random tiles
    function createBoard() {
        gameBoard = [];
        
        for (let row = 0; row < BOARD_SIZE; row++) {
            gameBoard[row] = [];
            for (let col = 0; col < BOARD_SIZE; col++) {
                // Assign a random tile type index (0-8), ensuring no initial matches
                let tileType;
                do {
                    tileType = Math.floor(Math.random() * ASSET_MAP.length);
                } while (
                    (row >= 2 && 
                     gameBoard[row-1][col] === tileType && 
                     gameBoard[row-2][col] === tileType) ||
                    (col >= 2 && 
                     gameBoard[row][col-1] === tileType && 
                     gameBoard[row][col-2] === tileType)
                );
                
                gameBoard[row][col] = tileType;
            }
        }
    }
    
    // Render the game board
    function renderBoard() {
        gameBoardElement.innerHTML = '';
        
        for (let row = 0; row < BOARD_SIZE; row++) {
            for (let col = 0; col < BOARD_SIZE; col++) {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.dataset.row = row;
                tile.dataset.col = col;
                
                const img = document.createElement('img');
                // Use the ASSET_MAP to get the correct image file
                const tileIndex = gameBoard[row][col];
                img.src = ASSET_MAP[tileIndex].imageFile;
                img.alt = ASSET_MAP[tileIndex].name;
                
                tile.appendChild(img);
                
                // Add click/touch event listeners
                tile.addEventListener('click', handleTileClick);
                
                gameBoardElement.appendChild(tile);
            }
        }
    }
// Start the game
function startGame() {
    startScreen.style.display = 'none';
    gameActive = true;
    score = 0;
    updateScore();
    createBoard();
    renderBoard();
    restartBtnGame.style.display = 'flex';
}

// Restart the game
function restartGame() {
    // Clear any ongoing game state
    selectedTile = null;
    isSwapping = false;
    isProcessing = false;
    
    // Reset UI elements
    startScreen.style.display = 'none';
    gameOverScreen.style.display = 'none';
    restartBtnGame.style.display = 'flex';
    
    // Reset game state
    gameActive = true;
    score = 0;
    updateScore();
    
    // Create and render new board
    createBoard();
    renderBoard();
}

// Update score display
function updateScore() {
    scoreElement.textContent = score;
}

// Handle tile click
function handleTileClick(event) {
    if (!gameActive || isSwapping || isProcessing) return;
    
    const tile = event.currentTarget;
    const row = parseInt(tile.dataset.row);
    const col = parseInt(tile.dataset.col);
    
    // If no tile is selected, select this one
    if (!selectedTile) {
        selectedTile = { row, col, element: tile };
        tile.classList.add('selected');
        return;
    }
    
    // If the same tile is clicked again, deselect it
    if (selectedTile.row === row && selectedTile.col === col) {
        selectedTile.element.classList.remove('selected');
        selectedTile = null;
        return;
    }
    
    // Check if the clicked tile is adjacent to the selected tile
    const isAdjacent = 
        (Math.abs(selectedTile.row - row) === 1 && selectedTile.col === col) ||
        (Math.abs(selectedTile.col - col) === 1 && selectedTile.row === row);
    
    if (isAdjacent) {
        // Swap the tiles
        swapTiles(selectedTile.row, selectedTile.col, row, col);
    } else {
        // Select the new tile instead
        selectedTile.element.classList.remove('selected');
        selectedTile = { row, col, element: tile };
        tile.classList.add('selected');
    }
}

// Swap two tiles
function swapTiles(row1, col1, row2, col2) {
    isSwapping = true;
    
    // Remove selection
    selectedTile.element.classList.remove('selected');
    selectedTile = null;
    
    // Swap in the game board array
    const temp = gameBoard[row1][col1];
    gameBoard[row1][col1] = gameBoard[row2][col2];
    gameBoard[row2][col2] = temp;
    
    // Get DOM elements for animation
    const tile1 = document.querySelector(`.tile[data-row="${row1}"][data-col="${col1}"]`);
    const tile2 = document.querySelector(`.tile[data-row="${row2}"][data-col="${col2}"]`);
    
    // Add swapping class for animation
    tile1.classList.add('swapping');
    tile2.classList.add('swapping');
    
    // After animation completes, check for matches
    setTimeout(() => {
        tile1.classList.remove('swapping');
        tile2.classList.remove('swapping');
        
        // Check if the swap created any matches
        const matches = findMatches();
        
        if (matches.length > 0) {
            // Play sound for the first matched tile type using the ASSET_MAP
            const firstMatchType = matches[0].type;
            playSound(firstMatchType);
            
            // Process matches
            processMatches(matches);
        } else {
            // Swap back if no matches were made
            const temp = gameBoard[row1][col1];
            gameBoard[row1][col1] = gameBoard[row2][col2];
            gameBoard[row2][col2] = temp;
            
            // Re-render the board
            renderBoard();
            isSwapping = false;
        }
    }, 300);
}

// Play sound for a specific tile type
function playSound(tileType) {
    // Reset the audio to start from beginning
    audioElements[tileType].currentTime = 0;
    // Play the sound
    audioElements[tileType].play().catch(e => {
        console.log("Audio play failed:", e);
        // This catch prevents errors if audio can't play (like on mobile without user interaction)
    });
}
        // Find all matches on the board
        function findMatches() {
            const matches = [];
            
            // Check horizontal matches
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE - 2; col++) {
                    const tileType = gameBoard[row][col];
                    if (tileType !== -1 && 
                        gameBoard[row][col+1] === tileType && 
                        gameBoard[row][col+2] === tileType) {
                        
                        // Find the full extent of the match
                        let matchLength = 3;
                        while (col + matchLength < BOARD_SIZE && 
                               gameBoard[row][col+matchLength] === tileType) {
                            matchLength++;
                        }
                        
                        // Add all tiles in the match
                        for (let i = 0; i < matchLength; i++) {
                            matches.push({ row, col: col + i, type: tileType });
                        }
                        
                        // Skip ahead since we've already matched these
                        col += matchLength - 1;
                    }
                }
            }
            
            // Check vertical matches
            for (let col = 0; col < BOARD_SIZE; col++) {
                for (let row = 0; row < BOARD_SIZE - 2; row++) {
                    const tileType = gameBoard[row][col];
                    if (tileType !== -1 && 
                        gameBoard[row+1][col] === tileType && 
                        gameBoard[row+2][col] === tileType) {
                        
                        // Find the full extent of the match
                        let matchLength = 3;
                        while (row + matchLength < BOARD_SIZE && 
                               gameBoard[row+matchLength][col] === tileType) {
                            matchLength++;
                        }
                        
                        // Add all tiles in the match
                        for (let i = 0; i < matchLength; i++) {
                            matches.push({ row: row + i, col, type: tileType });
                        }
                        
                        // Skip ahead since we've already matched these
                        row += matchLength - 1;
                    }
                }
            }
            
            // Remove duplicates (tiles that are in both horizontal and vertical matches)
            const uniqueMatches = [];
            const seen = {};
            
            for (const match of matches) {
                const key = `${match.row},${match.col}`;
                if (!seen[key]) {
                    seen[key] = true;
                    uniqueMatches.push(match);
                }
            }
            
            return uniqueMatches;
        }
        
        // Process matches - remove them and update the board
        function processMatches(matches) {
            isProcessing = true;
            
            // Mark matched tiles for removal
            for (const match of matches) {
                const tile = document.querySelector(`.tile[data-row="${match.row}"][data-col="${match.col}"]`);
                tile.classList.add('matched');
                
                // Update score
                score += 10;
                updateScore();
            }
            
            // After animation, remove matched tiles and drop new ones
            setTimeout(() => {
                // Remove matched tiles from the board
                for (const match of matches) {
                    gameBoard[match.row][match.col] = -1;
                }
                
                // Apply gravity - tiles fall down
                applyGravity();
                
                // Fill empty spaces with new tiles
                fillEmptySpaces();
                
                // Re-render the board
                renderBoard();
                
                // Check for cascading matches
                setTimeout(() => {
                    const newMatches = findMatches();
                    if (newMatches.length > 0) {
                        // Play sound for the first matched tile type using the ASSET_MAP
                        const firstMatchType = newMatches[0].type;
                        playSound(firstMatchType);
                        
                        processMatches(newMatches);
                    } else {
                        isSwapping = false;
                        isProcessing = false;
                        
                        // Check for game over condition (placeholder)
                        // In a full implementation, you would check for valid moves
                        // For now, we'll use a simple score threshold as a placeholder
                        if (score >= 500) {
                            endGame();
                        }
                    }
                }, 500);
            }, 500);
        }
        
        // End the game
        function endGame() {
            gameActive = false;
            finalScoreElement.textContent = score;
            gameOverScreen.style.display = 'flex';
            restartBtnGame.style.display = 'none';
        }
        
        // Apply gravity - make tiles fall down
        function applyGravity() {
            for (let col = 0; col < BOARD_SIZE; col++) {
                let emptySpaces = 0;
                
                // Check from bottom to top
                for (let row = BOARD_SIZE - 1; row >= 0; row--) {
                    if (gameBoard[row][col] === -1) {
                        emptySpaces++;
                    } else if (emptySpaces > 0) {
                        // Move tile down
                        gameBoard[row + emptySpaces][col] = gameBoard[row][col];
                        gameBoard[row][col] = -1;
                    }
                }
            }
        }
        
        // Fill empty spaces with new random tiles
        function fillEmptySpaces() {
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (gameBoard[row][col] === -1) {
                        gameBoard[row][col] = Math.floor(Math.random() * ASSET_MAP.length);
                    }
                }
            }
        }
        
        // Initialize the game when the page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>